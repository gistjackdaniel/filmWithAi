import { Injectable, NotFoundException, BadRequestException } from '@nestjs/common';
import { InjectModel } from '@nestjs/mongoose';
import { Model, Types } from 'mongoose';
import { Cut } from './schema/cut.schema';
import { 
  CreateCutRequestDto, 
  UpdateCutRequestDto,
  CreateCutDraftRequestDto
} from './dto/request.dto';
import { 
  CutResponseDto
} from './dto/response.dto';
import { AiService } from 'src/ai/ai.service';
import { SceneService } from 'src/scene/scene.service';
import { SceneResponseDto } from 'src/scene/dto/response.dto';
import { ProjectService } from 'src/project/project.service';
import { StorageFactoryService } from '../common/services/storage-factory.service';
import * as fs from 'fs';

@Injectable()
export class CutService {
  constructor(
    @InjectModel(Cut.name) private cutModel: Model<Cut>,
    private aiService: AiService,
    private sceneService: SceneService,
    private projectService: ProjectService,
    private storageFactoryService: StorageFactoryService
  ) {}

  async create(projectId: string, sceneId: string, createCutDto: CreateCutRequestDto): Promise<CutResponseDto> {
    const cut = new this.cutModel({
      ...createCutDto,
      isDeleted: false,
      projectId: new Types.ObjectId(projectId),
      sceneId: new Types.ObjectId(sceneId),
    });
    
    const savedCut = await cut.save();
    return this.mapToResponseDto(savedCut);
  }

  async createDraft(projectId: string, sceneId: string, createCutDraftRequestDto: CreateCutDraftRequestDto): Promise<CutResponseDto[]> {
    const project = await this.projectService.findById(projectId);
    const scene = await this.sceneService.findById(projectId, sceneId);
    const { maxCuts } = createCutDraftRequestDto;
    const { genre } = project;

    // Ïî¨ Ï†ïÎ≥¥Î•º Í∏∞Î∞òÏúºÎ°ú Ïª∑ ÏÉùÏÑ± ÌîÑÎ°¨ÌîÑÌä∏ ÏûëÏÑ±
    const cutPrompt = await this.buildCutPrompt(maxCuts, genre, scene);

    const result = await this.aiService.callChatCompletions([
      {
        role: 'system',
        content: 'ÎãπÏã†ÏùÄ ÏòÅÌôî Ï¥¨ÏòÅ Ï†ÑÎ¨∏Í∞ÄÏûÖÎãàÎã§. Ï†ïÌôïÌûà 3Í∞úÏùò Ïª∑Îßå ÏÉùÏÑ±ÌïòÍ≥† Ïú†Ìö®Ìïú JSON ÌòïÏãùÏúºÎ°úÎßå ÏùëÎãµÌïòÏÑ∏Ïöî. Í∞ÑÍ≤∞ÌïòÍ≤å ÏûëÏÑ±Ìï¥Ï£ºÏÑ∏Ïöî.'
      },
      {
        role: 'user',
        content: cutPrompt
      }
    ], { max_tokens: 4000, temperature: 0.3 });

    // AI ÏùëÎãµÏùÑ ÌååÏã±Ìï¥ÏÑú draft Ïª∑ Îç∞Ïù¥ÌÑ∞ ÏÉùÏÑ±
    const parsedCuts = this.parseCutDraftResponse(result);
    
    // draft Îç∞Ïù¥ÌÑ∞Ïóê projectIdÏôÄ sceneId Ï∂îÍ∞Ä
    const draftCuts: CutResponseDto[] = parsedCuts.map((cutData, index) => ({
      ...cutData,
      _id: new Types.ObjectId(), // ÏûÑÏãú ID
      sceneId: new Types.ObjectId(sceneId),
      projectId: new Types.ObjectId(projectId),
      order: cutData.order || (index + 1)
    }));

    return draftCuts;
  }

  private parseCutDraftResponse(content: string): CutResponseDto[] {
    console.log('üîç LLM ÏõêÎ≥∏ ÏùëÎãµ:', content.substring(0, 300) + '...');
    
    // ÎßàÌÅ¨Îã§Ïö¥ ÏΩîÎìú Î∏îÎ°ù Ï†úÍ±∞
    let jsonContent = content;
    
    // ```json ... ``` ÌòïÌÉúÏùò ÏΩîÎìú Î∏îÎ°ù Ï†úÍ±∞
    if (content.includes('```json')) {
      const jsonMatch = content.match(/```json\s*([\s\S]*?)\s*```/);
      if (jsonMatch) {
        jsonContent = jsonMatch[1].trim();
      }
    }
    
    // ``` ... ``` ÌòïÌÉúÏùò ÏΩîÎìú Î∏îÎ°ù Ï†úÍ±∞
    if (jsonContent.includes('```')) {
      const codeMatch = jsonContent.match(/```\s*([\s\S]*?)\s*```/);
      if (codeMatch) {
        jsonContent = codeMatch[1].trim();
      }
    }
    
    // JSON Í∞ùÏ≤¥ ÏãúÏûëÍ≥º ÎÅù Ï∞æÍ∏∞
    const jsonStart = jsonContent.indexOf('{');
    const jsonEnd = jsonContent.lastIndexOf('}');
    
    if (jsonStart !== -1 && jsonEnd !== -1 && jsonEnd > jsonStart) {
      jsonContent = jsonContent.substring(jsonStart, jsonEnd + 1);
    }
    
    console.log('üîç LLM ÏùëÎãµ Ï†ïÎ¶¨ ÌõÑ:', jsonContent.substring(0, 200) + '...');

    try {
      // JSON ÌååÏã± ÏãúÎèÑ
      let parsed;
      try {
        parsed = JSON.parse(jsonContent);
      } catch (parseError) {
        console.error('‚ùå JSON ÌååÏã± Ïã§Ìå®, Ïû¨ÏãúÎèÑ Ï§ë...');
        
        // Îçî Í∞ïÎ†•Ìïú JSON ÏàòÏ†ï ÏãúÎèÑ
        let fixedContent = jsonContent
          .replace(/,\s*}/g, '}') // ÎßàÏßÄÎßâ ÏâºÌëú Ï†úÍ±∞
          .replace(/,\s*]/g, ']') // Î∞∞Ïó¥ ÎßàÏßÄÎßâ ÏâºÌëú Ï†úÍ±∞
          .replace(/undefined/g, '""') // undefinedÎ•º Îπà Î¨∏ÏûêÏó¥Î°ú
          .replace(/null/g, '""') // nullÏùÑ Îπà Î¨∏ÏûêÏó¥Î°ú
          .replace(/NaN/g, '0') // NaNÏùÑ 0ÏúºÎ°ú
          .replace(/,\s*"([^"]+)":\s*$/gm, '') // Î∂àÏôÑÏ†ÑÌïú ÏÜçÏÑ± Ï†úÍ±∞
          .replace(/,\s*"([^"]+)":\s*"[^"]*$/gm, '') // Î∂àÏôÑÏ†ÑÌïú Î¨∏ÏûêÏó¥ Í∞í Ï†úÍ±∞
          .replace(/,\s*"([^"]+)":\s*\{[^}]*$/gm, '') // Î∂àÏôÑÏ†ÑÌïú Í∞ùÏ≤¥ Ï†úÍ±∞
          .replace(/,\s*"([^"]+)":\s*\[[^\]]*$/gm, '') // Î∂àÏôÑÏ†ÑÌïú Î∞∞Ïó¥ Ï†úÍ±∞;
        
        // Î∂àÏôÑÏ†ÑÌïú cutList Î∞∞Ïó¥ ÏàòÏ†ï
        if (fixedContent.includes('"cutList": [')) {
          const cutsStart = fixedContent.indexOf('"cutList": [');
          const cutsEnd = fixedContent.lastIndexOf(']');
          if (cutsEnd > cutsStart) {
            const beforeCuts = fixedContent.substring(0, cutsStart);
            const afterCuts = fixedContent.substring(cutsEnd + 1);
            fixedContent = beforeCuts + '"cutList": []' + afterCuts;
          }
        }
        
        try {
          parsed = JSON.parse(fixedContent);
        } catch (secondError) {
          console.error('‚ùå JSON ÌååÏã± Ïû¨ÏãúÎèÑ Ïã§Ìå®:', secondError.message);
          
          // ÏµúÌõÑÏùò ÏàòÎã®: Í∏∞Î≥∏ JSON Íµ¨Ï°∞ ÏÉùÏÑ±
          console.log('‚ö†Ô∏è Í∏∞Î≥∏ JSON Íµ¨Ï°∞Î°ú ÎåÄÏ≤¥');
          parsed = {
            cutList: []
          };
        }
      }
      
      // cutList Î∞∞Ïó¥ Í≤ÄÏ¶ù Î∞è ÏÉùÏÑ±
      if (parsed && parsed.cutList && Array.isArray(parsed.cutList) && parsed.cutList.length > 0) {
        console.log('‚úÖ LLM ÏùëÎãµ Íµ¨Ï°∞ Í≤ÄÏ¶ù ÏÑ±Í≥µ:', parsed.cutList.length, 'Í∞ú Ïª∑');
        
        // Í∞Å Ïª∑ Îç∞Ïù¥ÌÑ∞ Í≤ÄÏ¶ù Î∞è Ï†ïÎ¶¨
        const cutData: Array<CutResponseDto> = parsed.cutList.map((cut: any, index: number) => {
          // NaN Í∞íÎì§ÏùÑ Ï†ÅÏ†àÌïú Í∏∞Î≥∏Í∞íÏúºÎ°ú Î≥ÄÌôòÌïòÎäî Ìï®Ïàò
          const cleanDuration = (duration: any) => {
            if (typeof duration === 'string') {
              // "NaNÏ¥à", "5Ï¥à" Îì±Ïùò Î¨∏ÏûêÏó¥ Ï≤òÎ¶¨
              const match = duration.match(/(\d+)Ï¥à/);
              return match ? parseInt(match[1]) : 5;
            }
            if (typeof duration === 'number' && !isNaN(duration) && duration > 0) {
              return duration;
            }
            return 5; // Í∏∞Î≥∏Í∞í
          };

          const cleanNumber = (value: any) => {
            if (typeof value === 'number' && !isNaN(value) && value >= 0) {
              return value;
            }
            return 0;
          };

          const cleanString = (value: any) => {
            return typeof value === 'string' ? value.trim() : '';
          };

          // Cut Î™®Îç∏Ïóê ÎßûÎäî ÏïàÏ†ÑÌïú Ïª∑ Îç∞Ïù¥ÌÑ∞ ÏÉùÏÑ±
          return {
            _id: new Types.ObjectId(),
            sceneId: new Types.ObjectId(),
            projectId: new Types.ObjectId(),
            shotNumber: cleanNumber(cut.shotNumber) || (index + 1),
            title: cleanString(cut.title) || `Shot ${index + 1}`,
            description: cleanString(cut.description) || cleanString(cut.title) || `Shot ${index + 1}`,
            cameraSetup: {
              shotSize: cleanString(cut.cameraSetup?.shotSize) || 'MS',
              angleDirection: cleanString(cut.cameraSetup?.angleDirection) || 'Eye-level',
              cameraMovement: cleanString(cut.cameraSetup?.cameraMovement) || 'Static',
              lensSpecs: cleanString(cut.cameraSetup?.lensSpecs) || '50mm f/1.8',
              cameraSettings: cut.cameraSetup?.cameraSettings || {
                aperture: 'f/2.8',
                shutterSpeed: '1/60',
                iso: '800'
              }
            },
            vfxEffects: cleanString(cut.vfxEffects) || 'ÌäπÏàò Ìö®Í≥º ÏóÜÏùå',
            soundEffects: cleanString(cut.soundEffects) || 'Î∞∞Í≤ΩÏùå',
            directorNotes: cleanString(cut.directorNotes) || '',
            dialogue: cleanString(cut.dialogue) || '',
            narration: cleanString(cut.narration) || '',
            subjectMovement: cut.subjectMovement || [],
            productionMethod: cleanString(cut.productionMethod) || 'live_action',
            productionMethodReason: cleanString(cut.productionMethodReason) || 'Ïã§ÏÇ¨ Ï¥¨ÏòÅÏúºÎ°ú ÏûêÏó∞Ïä§Îü¨Ïö¥ Î∂ÑÏúÑÍ∏∞ Ïó∞Ï∂ú',
            estimatedDuration: cleanDuration(cut.estimatedDuration),
            specialRequirements: cut.specialRequirements || {
              specialCinematography: {
                drone: false,
                crane: false,
                jib: false,
                underwater: false,
                aerial: false
              },
              specialEffects: {
                vfx: false,
                pyrotechnics: false,
                smoke: false,
                fog: false,
                wind: false,
                rain: false,
                snow: false,
                fire: false,
                explosion: false,
                stunt: false
              },
              specialLighting: {
                laser: false,
                strobe: false,
                blackLight: false,
                uvLight: false,
                movingLight: false,
                colorChanger: false
              },
              safety: {
                requiresMedic: false,
                requiresFireSafety: false,
                requiresSafetyOfficer: false
              }
            },
            imageUrl: cleanString(cut.imageUrl) || '',
            order: cleanNumber(cut.shotNumber) || (index + 1),
            isDeleted: false
          };
        });
        
        return cutData;
      } else {
        throw new Error('AI ÏùëÎãµÏùÑ ÌååÏã±Ìï† Ïàò ÏóÜÏäµÎãàÎã§.');
      }
    } catch (error) {
      console.error('JSON ÌååÏã± Ïã§Ìå®:', error);
      console.error('ÌååÏã± ÏãúÎèÑÌïú ÎÇ¥Ïö©:', jsonContent);
      throw new Error('AI ÏùëÎãµÏùÑ ÌååÏã±Ìï† Ïàò ÏóÜÏäµÎãàÎã§.');
    }
  }

  async buildCutPrompt(maxCuts: number, genre: string[], scene: SceneResponseDto): Promise<string> {
    return `
title - ${scene.title}
description - ${scene.description}
dialogues - ${JSON.stringify(scene.dialogues)}
sceneDateTime - ${scene.timeOfDay}
weather - ${scene.weather}
lighting - ${JSON.stringify(scene.lighting)}
place - ${scene.scenePlace}
cast - ${JSON.stringify(scene.cast)}
visualDescription - ${scene.visualDescription}
vfxRequired - ${scene.vfxRequired}
sfxRequired - ${scene.sfxRequired}
genre - ${genre.join(', ')}

ÏµúÎåÄ ${maxCuts}Í∞ú Ïª∑ÏùÑ Îã§Ïùå ÌòïÏãùÏúºÎ°ú ÏÉùÏÑ±:
{
  "cutList": [
    {
      "order": 1,
      "title": "Ïª∑ Ï†úÎ™©",
      "description": "Ï¥¨ÏòÅ ÏÑ§Î™Ö",
      "cameraSetup": {
        "shotSize": "MS",
        "angleDirection": "Eye-level",
        "cameraMovement": "Static",
        "lensSpecs": "50mm f/1.8",
        "cameraSettings": {
          "aperture": "f/2.8",
          "shutterSpeed": "1/60",
          "iso": "800"
        }
      },
      "vfxEffects": "ÌäπÏàò Ìö®Í≥º ÏóÜÏùå",
      "soundEffects": "Î∞∞Í≤ΩÏùå",
      "dialogue": "ÎåÄÏÇ¨ ÎÇ¥Ïö©",
      "narration": "ÎÇ¥Î†àÏù¥ÏÖò ÎÇ¥Ïö©",
      "subjectMovement": [
        {
          "name": "Ï£ºÏù∏Í≥µ",
          "type": "character",
          "position": "ÌôîÎ©¥ Ï§ëÏïô",
          "action": "Ï≤úÏ≤úÌûà Í±∑Í∏∞",
          "emotion": "Ï∞®Î∂ÑÌï®",
          "description": "Ï£ºÏù∏Í≥µÏù¥ Ï≤úÏ≤úÌûà Í±∑Îäî Î™®Ïäµ"
        }
      ],
      "productionMethod": "live_action",
      "productionMethodReason": "Ïã§ÏÇ¨ Ï¥¨ÏòÅÏúºÎ°ú ÏûêÏó∞Ïä§Îü¨Ïö¥ Î∂ÑÏúÑÍ∏∞ Ïó∞Ï∂ú",
      "estimatedDuration": 8,
      "specialRequirements": {
        "specialCinematography": {
          "drone": false,
          "crane": false,
          "jib": false,
          "underwater": false,
          "aerial": false
        },
        "specialEffects": {
          "vfx": false,
          "pyrotechnics": false,
          "smoke": false,
          "fog": false,
          "wind": false,
          "rain": false,
          "snow": false,
          "fire": false,
          "explosion": false,
          "stunt": false
        },
        "specialLighting": {
          "laser": false,
          "strobe": false,
          "blackLight": false,
          "uvLight": false,
          "movingLight": false,
          "colorChanger": false
        },
        "safety": {
          "requiresMedic": false,
          "requiresFireSafety": false,
          "requiresSafetyOfficer": false
        }
      }
    }
  ]
}

Í∞Å Ïª∑ÏùÄ Îã§ÏùåÏùÑ Í≥†Î†§ÌïòÏó¨ ÏÉùÏÑ±:
- shotSize: EWS, VWS, WS, FS, LS, MLS, MS, MCS, CU, MCU, BCU, ECU, TCU, OTS, POV, TS, GS, AS, PS, BS Ï§ë ÏÑ†ÌÉù
- angleDirection: Eye-level, High, Low, Dutch, Bird_eye, Worm_eye, Canted, Oblique, Aerial, Ground, Overhead, Under, Side, Front, Back, Three_quarter, Profile, Reverse, POV, Subjective Ï§ë ÏÑ†ÌÉù  
- cameraMovement: Static, Pan, Tilt, Dolly, Zoom, Handheld, Tracking, Crane, Steadicam, Gimbal, Drone, Jib, Slider, Dolly_zoom, Arc, Circle, Spiral, Vertigo, Whip_pan, Crash_zoom, Push_in, Pull_out, Follow, Lead, Reveal, Conceal, Parallax, Time_lapse, Slow_motion, Fast_motion, Bullet_time, Matrix_style, 360_degree, VR_style Ï§ë ÏÑ†ÌÉù
- estimatedDuration: 1-30Ï¥à ÏÇ¨Ïù¥Ïùò Í∞í
- productionMethod: live_action ÎòêÎäî ai_generated Ï§ë ÏÑ†ÌÉù

Ïú†Ìö®Ìïú JSON ÌòïÏãùÏúºÎ°úÎßå ÏùëÎãµÌïòÏÑ∏Ïöî.
`;
  }

  async findByProjectId(projectId: string): Promise<CutResponseDto[]> {
    if (!Types.ObjectId.isValid(projectId)) {
      throw new BadRequestException('Invalid project ID');
    }

    const cuts = await this.cutModel.find({
      projectId: new Types.ObjectId(projectId),
      isDeleted: false
    })
    .sort({ order: 1 })
    .exec();

    return cuts.map(this.mapToResponseDto);
  }

  async findBySceneId(projectId: string, sceneId: string): Promise<CutResponseDto[]> {
    if (!Types.ObjectId.isValid(sceneId) || !Types.ObjectId.isValid(projectId)) {
      throw new BadRequestException('Invalid scene ID or project ID');
    }

    const cuts = await this.cutModel.find({
      sceneId: new Types.ObjectId(sceneId),
      projectId: new Types.ObjectId(projectId),
      isDeleted: false
    })
    .sort({ order: 1 })
    .exec();

    return cuts.map(this.mapToResponseDto);
  }

  async findById(projectId: string, sceneId: string, cutId: string): Promise<CutResponseDto> {
    if (!Types.ObjectId.isValid(cutId) || !Types.ObjectId.isValid(projectId) || !Types.ObjectId.isValid(sceneId)) {
      throw new BadRequestException('Invalid cut ID or project ID or scene ID');
    }

    const cut = await this.cutModel.findOne({
      _id: new Types.ObjectId(cutId),
      projectId: new Types.ObjectId(projectId),
      sceneId: new Types.ObjectId(sceneId),
      isDeleted: false
    }).exec();

    if (!cut) {
      throw new NotFoundException('Cut not found');
    }

    return this.mapToResponseDto(cut);
  }

  async update(projectId: string, sceneId: string, cutId: string, updateCutDto: UpdateCutRequestDto): Promise<CutResponseDto> {
    if (!Types.ObjectId.isValid(cutId) || !Types.ObjectId.isValid(projectId) || !Types.ObjectId.isValid(sceneId)) {
      throw new BadRequestException('Invalid cut ID or project ID or scene ID');
    }

    const cut = await this.cutModel.findOneAndUpdate(
      {
        _id: new Types.ObjectId(cutId),
        projectId: new Types.ObjectId(projectId),
        sceneId: new Types.ObjectId(sceneId),
        isDeleted: false
      },
      {
        ...updateCutDto,
      },
      { new: true }
    ).exec();

    if (!cut) {
      throw new NotFoundException('Cut not found');
    }

    return this.mapToResponseDto(cut);
  }

  async delete(projectId: string, sceneId: string, cutId: string): Promise<CutResponseDto> {
    if (!Types.ObjectId.isValid(cutId) || !Types.ObjectId.isValid(projectId) || !Types.ObjectId.isValid(sceneId)) {
      throw new BadRequestException('Invalid cut ID or project ID or scene ID');
    }

    const cut = await this.cutModel.findOneAndUpdate(
      {
        _id: new Types.ObjectId(cutId),
        sceneId: new Types.ObjectId(sceneId),
        projectId: new Types.ObjectId(projectId),
        isDeleted: false
      },
      {
        isDeleted: true,
      },
      { new: true }
    ).exec();

    if (!cut) {
      throw new NotFoundException('Cut not found');
    }

    return this.mapToResponseDto(cut);
  }

  async restore(projectId: string, sceneId: string, cutId: string): Promise<CutResponseDto> {
    if (!Types.ObjectId.isValid(cutId) || !Types.ObjectId.isValid(projectId) || !Types.ObjectId.isValid(sceneId)) {
      throw new BadRequestException('Invalid cut ID or project ID or scene ID');
    }

    const cut = await this.cutModel.findOneAndUpdate(
      {
        _id: new Types.ObjectId(cutId),
        sceneId: new Types.ObjectId(sceneId),
        projectId: new Types.ObjectId(projectId),
        isDeleted: true
      },
      {
        isDeleted: false,
      },
      { new: true }
    ).exec();

    if (!cut) {
      throw new NotFoundException('Deleted cut not found');
    }

    return this.mapToResponseDto(cut);
  }

  async updateOrder(projectId: string, sceneId: string, cutId: string, newOrder: number): Promise<CutResponseDto> {
    if (!Types.ObjectId.isValid(cutId) || !Types.ObjectId.isValid(projectId) || !Types.ObjectId.isValid(sceneId)) {
      throw new BadRequestException('Invalid cut ID or project ID or scene ID');
    }

    const cut = await this.cutModel.findOneAndUpdate(
      {
        _id: new Types.ObjectId(cutId),
        sceneId: new Types.ObjectId(sceneId),
        projectId: new Types.ObjectId(projectId),
        isDeleted: false
      },
      {
        order: newOrder,
      },
      { new: true }
    ).exec();

    if (!cut) {
      throw new NotFoundException('Cut not found');
    }

    return this.mapToResponseDto(cut);
  }

  async getImage(projectId: string, sceneId: string, cutId: string): Promise<string> {
    const cut = await this.findById(projectId, sceneId, cutId);
    return cut.imageUrl || '';
  }

  async uploadImage(
    projectId: string, 
    sceneId: string, 
    cutId: string, 
    file: Express.Multer.File
  ): Promise<string> {
    // Ïª∑ Ï°¥Ïû¨ ÌôïÏù∏
    const cut = await this.findById(projectId, sceneId, cutId);
    
    // Í∏∞Ï°¥ Ïù¥ÎØ∏ÏßÄÍ∞Ä ÏûàÎã§Î©¥ ÏÇ≠Ï†ú
    if (cut.imageUrl) {
      try {
        await this.storageFactoryService.deleteImage(cut.imageUrl);
      } catch (error) {
        console.warn('Í∏∞Ï°¥ Ïù¥ÎØ∏ÏßÄ ÏÇ≠Ï†ú Ïã§Ìå®:', error);
      }
    }

    // ÌååÏùºÏùÑ base64Î°ú Î≥ÄÌôò
    const base64Data = file.buffer.toString('base64');
    const mimeType = file.mimetype;
    const imageData = `data:${mimeType};base64,${base64Data}`;

    // ÏÉà Ïù¥ÎØ∏ÏßÄ ÏóÖÎ°úÎìú
    const fileName = `cut_${cutId}_${Date.now()}_${file.originalname}`;
    const imageUrl = await this.storageFactoryService.uploadImage(
      imageData,
      fileName
    );

    // Ïª∑ ÏóÖÎç∞Ïù¥Ìä∏
    await this.cutModel.findOneAndUpdate(
      {
        _id: new Types.ObjectId(cutId),
        projectId: new Types.ObjectId(projectId),
        sceneId: new Types.ObjectId(sceneId),
        isDeleted: false
      },
      {
        imageUrl: imageUrl
      }
    );

    return imageUrl;
  }

  async deleteImage(projectId: string, sceneId: string, cutId: string): Promise<string> {
    const cut = await this.findById(projectId, sceneId, cutId);
    
    if (cut.imageUrl) {
      try {
        await this.storageFactoryService.deleteImage(cut.imageUrl);
      } catch (error) {
        console.warn('Ïù¥ÎØ∏ÏßÄ ÏÇ≠Ï†ú Ïã§Ìå®:', error);
      }
    }

    // Ïª∑ÏóêÏÑú Ïù¥ÎØ∏ÏßÄ URL Ï†úÍ±∞
    await this.cutModel.findOneAndUpdate(
      {
        _id: new Types.ObjectId(cutId),
        projectId: new Types.ObjectId(projectId),
        sceneId: new Types.ObjectId(sceneId),
        isDeleted: false
      },
      {
        imageUrl: ''
      }
    );

    return 'Ïù¥ÎØ∏ÏßÄÍ∞Ä ÏÑ±Í≥µÏ†ÅÏúºÎ°ú ÏÇ≠Ï†úÎêòÏóàÏäµÎãàÎã§.';
  }

  async generateImage(projectId: string, sceneId: string, cutId: string): Promise<string> {
    const cut = await this.findById(projectId, sceneId, cutId);
    
    // AI Ïù¥ÎØ∏ÏßÄ ÏÉùÏÑ± ÌîÑÎ°¨ÌîÑÌä∏ ÏûëÏÑ±
    const prompt = this.buildImageGenerationPrompt(cut);
    
    try {
      // AI ÏÑúÎπÑÏä§Î•º ÌÜµÌï¥ Ïù¥ÎØ∏ÏßÄ ÏÉùÏÑ±
      const imageResult = await this.aiService.callImageGenerations(prompt, {
        model: 'dall-e-3',
        size: '1024x1024',
        quality: 'standard'
      });

      if (imageResult.data && imageResult.data.length > 0) {
        const imageUrl = imageResult.data[0].url;
        
        // Í∏∞Ï°¥ Ïù¥ÎØ∏ÏßÄÍ∞Ä ÏûàÎã§Î©¥ ÏÇ≠Ï†ú
        if (cut.imageUrl) {
          try {
            await this.storageFactoryService.deleteImage(cut.imageUrl);
          } catch (error) {
            console.warn('Í∏∞Ï°¥ Ïù¥ÎØ∏ÏßÄ ÏÇ≠Ï†ú Ïã§Ìå®:', error);
          }
        }

        // AIÏóêÏÑú ÏÉùÏÑ±Îêú Ïù¥ÎØ∏ÏßÄÎ•º Îã§Ïö¥Î°úÎìú
        const fileName = `ai_generated_${cutId}_${Date.now()}.png`;
        const tempFilePath = await this.aiService.downloadImageFromUrl(imageUrl, fileName);

        try {
          // Îã§Ïö¥Î°úÎìúÌïú ÌååÏùºÏùÑ base64Î°ú Î≥ÄÌôò
          const fileBuffer = fs.readFileSync(tempFilePath);
          const base64Data = fileBuffer.toString('base64');
          const imageData = `data:image/png;base64,${base64Data}`;

          // Ïä§ÌÜ†Î¶¨ÏßÄ ÏÑúÎπÑÏä§Ïóê ÏóÖÎ°úÎìú
          const storageFileName = `cut_${cutId}_${Date.now()}_ai_generated.png`;
          const storageImageUrl = await this.storageFactoryService.uploadImage(
            imageData,
            storageFileName
          );

          // Ïª∑ ÏóÖÎç∞Ïù¥Ìä∏
          await this.cutModel.findOneAndUpdate(
            {
              _id: new Types.ObjectId(cutId),
              projectId: new Types.ObjectId(projectId),
              sceneId: new Types.ObjectId(sceneId),
              isDeleted: false
            },
            {
              imageUrl: storageImageUrl
            }
          );

          return storageImageUrl;
        } finally {
          // ÏûÑÏãú ÌååÏùº Ï†ïÎ¶¨
          await this.aiService.cleanupTempFile(tempFilePath);
        }
      } else {
        throw new Error('AI Ïù¥ÎØ∏ÏßÄ ÏÉùÏÑ±Ïóê Ïã§Ìå®ÌñàÏäµÎãàÎã§.');
      }
    } catch (error) {
      console.error('AI Ïù¥ÎØ∏ÏßÄ ÏÉùÏÑ± Ïã§Ìå®:', error);
      throw new Error('AI Ïù¥ÎØ∏ÏßÄ ÏÉùÏÑ±Ïóê Ïã§Ìå®ÌñàÏäµÎãàÎã§.');
    }
  }

  private buildImageGenerationPrompt(cut: CutResponseDto): string {
    const { title, description, cameraSetup, subjectMovement, productionMethod } = cut;
    
    let prompt = `ÏòÅÌôî Ï¥¨ÏòÅ Ïª∑ Ïù¥ÎØ∏ÏßÄ: ${title || 'ÏòÅÌôî Ï¥¨ÏòÅ Ïª∑'}`;
    
    if (description) {
      prompt += `\nÏÑ§Î™Ö: ${description}`;
    }
    
    if (cameraSetup) {
      prompt += `\nÏπ¥Î©îÎùº ÏÑ§Ï†ï:`;
      if (cameraSetup.shotSize) prompt += ` ÏÉ∑ ÏÇ¨Ïù¥Ï¶à: ${cameraSetup.shotSize}`;
      if (cameraSetup.angleDirection) prompt += ` ÏïµÍ∏Ä: ${cameraSetup.angleDirection}`;
      if (cameraSetup.cameraMovement) prompt += ` Ïπ¥Î©îÎùº ÏõÄÏßÅÏûÑ: ${cameraSetup.cameraMovement}`;
      if (cameraSetup.lensSpecs) prompt += ` Î†åÏ¶à: ${cameraSetup.lensSpecs}`;
    }
    
    if (subjectMovement && subjectMovement.length > 0) {
      prompt += `\nÌîºÏÇ¨Ï≤¥:`;
      subjectMovement.forEach(subject => {
        prompt += ` ${subject.name}(${subject.type})`;
        if (subject.position) prompt += ` ÏúÑÏπò: ${subject.position}`;
        if (subject.action) prompt += ` ÌñâÎèô: ${subject.action}`;
        if (subject.emotion) prompt += ` Í∞êÏ†ï: ${subject.emotion}`;
      });
    }
    
    if (productionMethod) {
      prompt += `\nÏ†úÏûë Î∞©Î≤ï: ${productionMethod === 'ai_generated' ? 'AI ÏÉùÏÑ±' : 'Ïã§ÏÇ¨ Ï¥¨ÏòÅ'}`;
    }
    
    prompt += `\n\nÍ≥†ÌíàÏßà ÏòÅÌôî Ï¥¨ÏòÅ Ïª∑ Ïù¥ÎØ∏ÏßÄ, ÏãúÎÑ§ÎßàÌã±Ìïú Î∂ÑÏúÑÍ∏∞, Ï†ÑÎ¨∏Ï†ÅÏù∏ Ï¥¨ÏòÅ Ïä§ÌÉÄÏùº`;
    
    return prompt;
  }

  getStorageInfo(): { type: string; bucket?: string; localPath?: string } {
    return this.storageFactoryService.getStorageInfo();
  }

  private mapToResponseDto(cut: Cut): CutResponseDto {
    return {
      _id: cut._id,
      sceneId: cut.sceneId,
      projectId: cut.projectId,
      title: cut.title,
      description: cut.description,
      cameraSetup: cut.cameraSetup,
      vfxEffects: cut.vfxEffects,
      soundEffects: cut.soundEffects,
      directorNotes: cut.directorNotes,
      dialogue: cut.dialogue,
      narration: cut.narration,
      subjectMovement: cut.subjectMovement,
      productionMethod: cut.productionMethod,
      productionMethodReason: cut.productionMethodReason,
      estimatedDuration: cut.estimatedDuration,
      specialRequirements: cut.specialRequirements,
      imageUrl: cut.imageUrl,
      order: cut.order,
      isDeleted: cut.isDeleted,
    };
  }
} 