import { create } from 'zustand'
import { SceneType } from '../types/conte'
import timelineService from '../services/timelineService'
import { cutAPI } from '../services/api'
import { useAuthStore } from './authStore'

/**
 * ÌÉÄÏûÑÎùºÏù∏ ÏÉÅÌÉú Í¥ÄÎ¶¨ Ïä§ÌÜ†Ïñ¥
 * Ïª∑ Îç∞Ïù¥ÌÑ∞ÏôÄ ÌÉÄÏûÑÎùºÏù∏ Í¥ÄÎ†® ÏÉÅÌÉúÎ•º Í¥ÄÎ¶¨ (Ïî¨ Í∏∞Îä•ÎèÑ Ïú†ÏßÄ)
 */
const useTimelineStore = create((set, get) => ({
  // ÏÉÅÌÉú
  cuts: [],                      // Ïª∑ Î∞∞Ïó¥ (ÌÉÄÏûÑÎùºÏù∏Ïö©)
  scenes: [],                    // Ïî¨ Î∞∞Ïó¥ (Ïä§ÏºÄÏ§ÑÎü¨Ïö©)
  selectedCutId: null,           // ÏÑ†ÌÉùÎêú Ïª∑ ID
  selectedSceneId: null,         // ÏÑ†ÌÉùÎêú Ïî¨ ID
  loading: false,                // Î°úÎî© ÏÉÅÌÉú
  error: null,                   // ÏóêÎü¨ ÏÉÅÌÉú
  currentProjectId: null,        // ÌòÑÏû¨ ÌîÑÎ°úÏ†ùÌä∏ ID
  websocketConnection: null,     // WebSocket Ïó∞Í≤∞
  filters: {                     // ÌïÑÌÑ∞ ÏÉÅÌÉú
    type: null,
    dateRange: null,
    location: null,
    character: null,
    equipment: null,
  },
  sortBy: 'cut_number',          // Ï†ïÎ†¨ Í∏∞Ï§Ä
  modalOpen: false,              // Î™®Îã¨ Ïó¥Î¶º ÏÉÅÌÉú
  currentCut: null,              // ÌòÑÏû¨ ÏÑ†ÌÉùÎêú Ïª∑
  currentScene: null,            // ÌòÑÏû¨ ÏÑ†ÌÉùÎêú Ïî¨

  // Ïï°ÏÖòÎì§

  /**
   * ÏÇ¨Ïö©ÏûêÎ≥Ñ Îç∞Ïù¥ÌÑ∞ Î°úÎìú
   * @param {string} userId - ÏÇ¨Ïö©Ïûê ID
   */
  loadUserData: (userId) => {
    if (!userId) return
    
    try {
      const savedData = localStorage.getItem(`timeline-data-${userId}`)
      if (savedData) {
        const data = JSON.parse(savedData)
        set(data)
        console.log('User timeline data loaded for:', userId)
      }
    } catch (error) {
      console.warn('Failed to load user timeline data:', error)
    }
  },

  /**
   * ÏÇ¨Ïö©ÏûêÎ≥Ñ Îç∞Ïù¥ÌÑ∞ Ï†ÄÏû•
   * @param {string} userId - ÏÇ¨Ïö©Ïûê ID
   */
  saveUserData: (userId) => {
    if (!userId) return
    
    try {
      const currentState = get()
      const dataToSave = {
        cuts: currentState.cuts,
        scenes: currentState.scenes,
        selectedCutId: currentState.selectedCutId,
        selectedSceneId: currentState.selectedSceneId,
        currentProjectId: currentState.currentProjectId,
        filters: currentState.filters,
        sortBy: currentState.sortBy,
        currentCut: currentState.currentCut,
        currentScene: currentState.currentScene
      }
      
      localStorage.setItem(`timeline-data-${userId}`, JSON.stringify(dataToSave))
      console.log('User timeline data saved for:', userId)
    } catch (error) {
      console.warn('Failed to save user timeline data:', error)
    }
  },

  /**
   * Î™®Îì† Îç∞Ïù¥ÌÑ∞ Ï¥àÍ∏∞Ìôî
   */
  clearAllData: () => {
    set({
      cuts: [],
      scenes: [],
      selectedCutId: null,
      selectedSceneId: null,
      loading: false,
      error: null,
      currentProjectId: null,
      websocketConnection: null,
      filters: {
        type: null,
        dateRange: null,
        location: null,
        character: null,
        equipment: null,
      },
      sortBy: 'cut_number',
      modalOpen: false,
      currentCut: null,
      currentScene: null
    })
    console.log('All timeline data cleared')
  },

  /**
   * Ïª∑Îì§ ÏÑ§Ï†ï (ÌÉÄÏûÑÎùºÏù∏Ïö©)
   */
  setCuts: (cuts) => {
    console.log('üîß timelineStore setCuts Ìò∏Ï∂úÎê®')
    console.log('  - Ï†ÑÎã¨Î∞õÏùÄ cuts ÌÉÄÏûÖ:', typeof cuts)
    console.log('  - Ï†ÑÎã¨Î∞õÏùÄ cutsÍ∞Ä Î∞∞Ïó¥Ïù∏Í∞Ä:', Array.isArray(cuts))
    console.log('  - Ï†ÑÎã¨Î∞õÏùÄ cuts Í∏∏Ïù¥:', cuts?.length || 0)
    
    if (cuts && Array.isArray(cuts)) {
      console.log('‚úÖ timelineStore Ïú†Ìö®Ìïú cuts Îç∞Ïù¥ÌÑ∞ ÏàòÏã†')
      
      // Ïª∑ Îç∞Ïù¥ÌÑ∞ ÏÉÅÏÑ∏ Î∂ÑÏÑù Î°úÍ∑∏ Ï∂îÍ∞Ä
      console.log('üé¨ timelineStore Ïª∑ Îç∞Ïù¥ÌÑ∞ ÏÉÅÏÑ∏ Î∂ÑÏÑù:')
      cuts.forEach((cut, index) => {
        console.log(`üé¨ timelineStore Ïª∑ ${index + 1} Ï†ïÎ≥¥:`)
        console.log('  - ID:', cut.id)
        console.log('  - Ïª∑ Î≤àÌò∏:', cut.shotNumber)
        console.log('  - Ï†úÎ™©:', cut.title)
        console.log('  - Ïª∑ ÌÉÄÏûÖ:', cut.cutType)
        console.log('  - ÏòàÏÉÅ ÏãúÍ∞Ñ:', cut.estimatedDuration)
        console.log('  - Ïã§Ï†ú ÏãúÍ∞Ñ(Ï¥à):', cut.duration)
        console.log('  - Ïî¨ ID:', cut.sceneId)
        console.log('  - Ïî¨ Î≤àÌò∏:', cut.sceneNumber)
        console.log('  - Ïî¨ Ï†úÎ™©:', cut.sceneTitle)
        console.log('  - Ïù¥ÎØ∏ÏßÄ URL Ï°¥Ïû¨:', !!cut.imageUrl)
        console.log('  - Ïù¥ÎØ∏ÏßÄ URL Í∞í:', cut.imageUrl)
        console.log('  ---')
      })
    } else {
      console.log('‚ùå timelineStore Ïú†Ìö®ÌïòÏßÄ ÏïäÏùÄ cuts Îç∞Ïù¥ÌÑ∞:', cuts)
    }
    
    set({ cuts, loading: false, error: null })
    console.log('‚úÖ timelineStore cuts ÏÑ§Ï†ï ÏôÑÎ£å')
    
    // ÏÇ¨Ïö©ÏûêÎ≥Ñ Îç∞Ïù¥ÌÑ∞ Ï†ÄÏû•
    const { user } = useAuthStore.getState()
    if (user && user.id) {
      get().saveUserData(user.id)
      console.log('üíæ timelineStore ÏÇ¨Ïö©ÏûêÎ≥Ñ Îç∞Ïù¥ÌÑ∞ Ï†ÄÏû• ÏôÑÎ£å')
    }
  },

  /**
   * ÌòÑÏû¨ ÌîÑÎ°úÏ†ùÌä∏ ID ÏÑ§Ï†ï
   */
  setCurrentProjectId: (projectId) => {
    console.log('üîß timelineStore setCurrentProjectId Ìò∏Ï∂úÎê®:', projectId)
    set({ currentProjectId: projectId })
    console.log('‚úÖ timelineStore currentProjectId ÏÑ§Ï†ï ÏôÑÎ£å:', projectId)
    
    // ÏÇ¨Ïö©ÏûêÎ≥Ñ Îç∞Ïù¥ÌÑ∞ Ï†ÄÏû•
    const { user } = useAuthStore.getState()
    if (user && user.id) {
      get().saveUserData(user.id)
      console.log('üíæ timelineStore ÏÇ¨Ïö©ÏûêÎ≥Ñ Îç∞Ïù¥ÌÑ∞ Ï†ÄÏû• ÏôÑÎ£å')
    }
  },

  /**
   * Ïî¨Îì§ ÏÑ§Ï†ï (Ïä§ÏºÄÏ§ÑÎü¨Ïö©)
   */
  setScenes: (scenes) => {
    console.log('üîß timelineStore setScenes Ìò∏Ï∂úÎê®')
    console.log('  - Ï†ÑÎã¨Î∞õÏùÄ scenes ÌÉÄÏûÖ:', typeof scenes)
    console.log('  - Ï†ÑÎã¨Î∞õÏùÄ scenesÍ∞Ä Î∞∞Ïó¥Ïù∏Í∞Ä:', Array.isArray(scenes))
    console.log('  - Ï†ÑÎã¨Î∞õÏùÄ scenes Í∏∏Ïù¥:', scenes?.length || 0)
    
    if (scenes && Array.isArray(scenes)) {
      console.log('‚úÖ timelineStore Ïú†Ìö®Ìïú scenes Îç∞Ïù¥ÌÑ∞ ÏàòÏã†')
      
      // Ïî¨ Îç∞Ïù¥ÌÑ∞ ÏÉÅÏÑ∏ Î∂ÑÏÑù Î°úÍ∑∏ Ï∂îÍ∞Ä
      console.log('üé¨ timelineStore Ïî¨ Îç∞Ïù¥ÌÑ∞ ÏÉÅÏÑ∏ Î∂ÑÏÑù:')
      scenes.forEach((scene, index) => {
        console.log(`üìù timelineStore Ïî¨ ${index + 1} Ï†ïÎ≥¥:`)
        console.log('  - ID:', scene.id)
        console.log('  - Ïî¨ Î≤àÌò∏:', scene.scene)
        console.log('  - Ï†úÎ™©:', scene.title)
        console.log('  - ÏÑ§Î™Ö:', scene.description)
        console.log('  - ÏòàÏÉÅ ÏãúÍ∞Ñ:', scene.estimatedDuration)
        console.log('  - Ïã§Ï†ú ÏãúÍ∞Ñ(Ï¥à):', scene.duration)
        console.log('  - Ïù¥ÎØ∏ÏßÄ URL Ï°¥Ïû¨:', !!scene.imageUrl)
        console.log('  - Ïù¥ÎØ∏ÏßÄ URL Í∞í:', scene.imageUrl)
        console.log('  - Ïª∑ Í∞úÏàò:', scene.cuts?.length || 0)
        console.log('  ---')
      })
    } else {
      console.log('‚ùå timelineStore Ïú†Ìö®ÌïòÏßÄ ÏïäÏùÄ scenes Îç∞Ïù¥ÌÑ∞:', scenes)
    }
    
    set({ scenes, loading: false, error: null })
    console.log('‚úÖ timelineStore scenes ÏÑ§Ï†ï ÏôÑÎ£å')
    
    // ÏÇ¨Ïö©ÏûêÎ≥Ñ Îç∞Ïù¥ÌÑ∞ Ï†ÄÏû•
    const { user } = useAuthStore.getState()
    if (user && user.id) {
      get().saveUserData(user.id)
      console.log('üíæ timelineStore ÏÇ¨Ïö©ÏûêÎ≥Ñ Îç∞Ïù¥ÌÑ∞ Ï†ÄÏû• ÏôÑÎ£å')
    }
  },

  /**
   * Ïª∑ Ï∂îÍ∞Ä
   */
  addCut: (cut) => {
    set((state) => ({
      cuts: [...state.cuts, cut]
    }))
  },

  /**
   * Ïª∑ ÏóÖÎç∞Ïù¥Ìä∏
   */
  updateCut: (cutId, updates) => {
    set((state) => ({
      cuts: state.cuts.map(cut =>
        cut.id === cutId ? { ...cut, ...updates } : cut
      )
    }))
  },

  /**
   * Ïª∑ ÏÑ†ÌÉù
   */
  selectCut: (cutId) => {
    set({ selectedCutId: cutId })
    console.log('üé¨ timelineStore Ïª∑ ÏÑ†ÌÉù:', cutId)
  },

  /**
   * Ïª∑ ÏÇ≠Ï†ú
   */
  deleteCut: (cutId) => {
    set((state) => ({
      cuts: state.cuts.filter(cut => cut.id !== cutId),
      selectedCutId: state.selectedCutId === cutId ? null : state.selectedCutId
    }))
  },

  /**
   * Ïî¨ Ï∂îÍ∞Ä
   */
  addScene: (scene) => {
    set((state) => ({
      scenes: [...state.scenes, scene]
    }))
  },

  /**
   * Ïî¨ ÏóÖÎç∞Ïù¥Ìä∏
   */
  updateScene: (sceneId, updates) => {
    set((state) => ({
      scenes: state.scenes.map(scene =>
        scene.id === sceneId ? { ...scene, ...updates } : scene
      )
    }))
  },

  /**
   * Ïî¨ ÏÇ≠Ï†ú
   */
  deleteScene: (sceneId) => {
    set((state) => ({
      scenes: state.scenes.filter(scene => scene.id !== sceneId),
      selectedSceneId: state.selectedSceneId === sceneId ? null : state.selectedSceneId
    }))
  },

  /**
   * ÌîÑÎ°úÏ†ùÌä∏ Ïª∑ Îç∞Ïù¥ÌÑ∞ Î°úÎìú (ÌÉÄÏûÑÎùºÏù∏Ïö©)
   */
  loadProjectCuts: async (projectId) => {
    try {
      console.log('timelineStore loadProjectCuts started for projectId:', projectId)
      
      set({ loading: true, error: null, currentProjectId: projectId })
      
      // Ï∫êÏãú ÌôïÏù∏
      const cacheKey = `project_cuts_${projectId}`
      const cached = timelineService.getCachedData(cacheKey)
      if (cached) {
        console.log('timelineStore using cached cuts data for projectId:', projectId)
        set({ 
          cuts: cached, 
          loading: false, 
          currentProjectId: projectId,
          error: null
        })
        return { success: true, data: cached }
      }

      // APIÏóêÏÑú Îç∞Ïù¥ÌÑ∞ Í∞ÄÏ†∏Ïò§Í∏∞
      console.log('timelineStore fetching cuts data from API for projectId:', projectId)
      const result = await timelineService.getProjectCuts(projectId)
      console.log('timelineStore API result:', result)
      console.log('timelineStore API result type:', typeof result)
      console.log('timelineStore API result.success:', result?.success)
      console.log('timelineStore API result.data:', result?.data)
      
      if (result && result.success && result.data) {
        console.log('timelineStore API success, cuts count:', result.data.length)
        
        // Îç∞Ïù¥ÌÑ∞ Ïú†Ìö®ÏÑ± Í≤ÄÏÇ¨
        if (!Array.isArray(result.data)) {
          console.error('timelineStore API returned non-array data:', result.data)
          set({ 
            loading: false, 
            error: 'ÏÑúÎ≤ÑÏóêÏÑú ÏûòÎ™ªÎêú Îç∞Ïù¥ÌÑ∞ ÌòïÏãùÏùÑ Î∞õÏïòÏäµÎãàÎã§.' 
          })
          return { success: false, error: 'ÏÑúÎ≤ÑÏóêÏÑú ÏûòÎ™ªÎêú Îç∞Ïù¥ÌÑ∞ ÌòïÏãùÏùÑ Î∞õÏïòÏäµÎãàÎã§.' }
        }
        
        // Ïª∑ Îç∞Ïù¥ÌÑ∞ ÏÉÅÏÑ∏ Î∂ÑÏÑù
        console.log('üîç timelineStore Ïª∑ Îç∞Ïù¥ÌÑ∞ ÏÉÅÏÑ∏ Î∂ÑÏÑù:')
        result.data.forEach((cut, index) => {
          console.log(`üé¨ timelineStore Ïª∑ ${index + 1} Î∂ÑÏÑù:`, {
            cutId: cut.id,
            shotNumber: cut.shotNumber,
            title: cut.title,
            description: cut.description,
            cutType: cut.cutType,
            estimatedDuration: cut.estimatedDuration,
            duration: cut.duration,
            imageUrl: cut.imageUrl,
            sceneId: cut.sceneId,
            sceneNumber: cut.sceneNumber,
            sceneTitle: cut.sceneTitle
          })
        })
        
        // Ï∫êÏãúÏóê Ï†ÄÏû•
        timelineService.setCachedData(`project_${projectId}`, result.data)
        
        set({ 
          cuts: result.data, 
          loading: false, 
          currentProjectId: projectId,
          error: null 
        })
        
        // Ïã§ÏãúÍ∞Ñ ÏóÖÎç∞Ïù¥Ìä∏ Ïó∞Í≤∞ (ÏÑ†ÌÉùÏ†Å)
        try {
          console.log('timelineStore connecting realtime updates')
          get().connectRealtimeUpdates(projectId)
        } catch (wsError) {
          console.warn('timelineStore WebSocket connection failed:', wsError)
          // WebSocket Ïó∞Í≤∞ Ïã§Ìå®Îäî ÏπòÎ™ÖÏ†ÅÏù¥ÏßÄ ÏïäÏúºÎØÄÎ°ú Í≥ÑÏÜç ÏßÑÌñâ
        }
        
        return { success: true, data: result.data }
      } else {
        console.error('timelineStore API failed:', result)
        const errorMessage = result?.error || 'Îç∞Ïù¥ÌÑ∞Î•º Î∂àÎü¨Ïò¨ Ïàò ÏóÜÏäµÎãàÎã§.'
        set({ 
          loading: false, 
          error: errorMessage
        })
        return { success: false, error: errorMessage }
      }
    } catch (error) {
      console.error('timelineStore loadProjectCuts error:', error)
      const errorMessage = 'Ïª∑ Îç∞Ïù¥ÌÑ∞Î•º Î∂àÎü¨Ïò§ÎäîÎç∞ Ïã§Ìå®ÌñàÏäµÎãàÎã§.'
      set({ loading: false, error: errorMessage })
      return { success: false, error: errorMessage }
    }
  },

  /**
   * ÌîÑÎ°úÏ†ùÌä∏ Ïî¨ Îç∞Ïù¥ÌÑ∞ Î°úÎìú (Ïä§ÏºÄÏ§ÑÎü¨Ïö©)
   */
  loadProjectScenes: async (projectId) => {
    try {
      console.log('timelineStore loadProjectScenes started for projectId:', projectId)
      
      set({ loading: true, error: null, currentProjectId: projectId })
      
      // Ï∫êÏãú ÌôïÏù∏
      const cacheKey = `project_scenes_${projectId}`
      const cached = timelineService.getCachedData(cacheKey)
      if (cached) {
        console.log('timelineStore using cached scenes data for projectId:', projectId)
        set({ 
          scenes: cached, 
          loading: false, 
          currentProjectId: projectId,
          error: null
        })
        return { success: true, data: cached }
      }

      // APIÏóêÏÑú Îç∞Ïù¥ÌÑ∞ Í∞ÄÏ†∏Ïò§Í∏∞
      console.log('timelineStore fetching scenes data from API for projectId:', projectId)
      const result = await timelineService.getProjectContes(projectId)
      console.log('timelineStore API result:', result)
      
      if (result && result.success && result.data) {
        console.log('timelineStore API success, scenes count:', result.data.length)
        
        // Îç∞Ïù¥ÌÑ∞ Ïú†Ìö®ÏÑ± Í≤ÄÏÇ¨
        if (!Array.isArray(result.data)) {
          console.error('timelineStore API returned non-array data:', result.data)
          set({ 
            loading: false, 
            error: 'ÏÑúÎ≤ÑÏóêÏÑú ÏûòÎ™ªÎêú Îç∞Ïù¥ÌÑ∞ ÌòïÏãùÏùÑ Î∞õÏïòÏäµÎãàÎã§.' 
          })
          return { success: false, error: 'ÏÑúÎ≤ÑÏóêÏÑú ÏûòÎ™ªÎêú Îç∞Ïù¥ÌÑ∞ ÌòïÏãùÏùÑ Î∞õÏïòÏäµÎãàÎã§.' }
        }
        
        // Ï∫êÏãúÏóê Ï†ÄÏû•
        timelineService.setCachedData(`project_scenes_${projectId}`, result.data)
        
        set({ 
          scenes: result.data, 
          loading: false, 
          currentProjectId: projectId,
          error: null 
        })
        
        return { success: true, data: result.data }
      } else {
        console.error('timelineStore API failed:', result)
        const errorMessage = result?.error || 'Îç∞Ïù¥ÌÑ∞Î•º Î∂àÎü¨Ïò¨ Ïàò ÏóÜÏäµÎãàÎã§.'
        set({ 
          loading: false, 
          error: errorMessage
        })
        return { success: false, error: errorMessage }
      }
    } catch (error) {
      console.error('timelineStore loadProjectScenes error:', error)
      const errorMessage = 'Ïî¨ Îç∞Ïù¥ÌÑ∞Î•º Î∂àÎü¨Ïò§ÎäîÎç∞ Ïã§Ìå®ÌñàÏäµÎãàÎã§.'
      set({ loading: false, error: errorMessage })
      return { success: false, error: errorMessage }
    }
  },

  /**
   * Ïª∑ ÏÉÅÏÑ∏ Ï†ïÎ≥¥ Î°úÎìú
   */
  loadCutDetails: async (cutId) => {
    const { currentProjectId } = get()
    if (!currentProjectId) {
      return { success: false, error: 'ÌîÑÎ°úÏ†ùÌä∏Í∞Ä ÏÑ†ÌÉùÎêòÏßÄ ÏïäÏïòÏäµÎãàÎã§.' }
    }

    try {
      console.log('timelineStore loadCutDetails started for cutId:', cutId)
      const result = await timelineService.getCutDetails(currentProjectId, cutId)
      
      if (result.success) {
        // ÌòÑÏû¨ Ïª∑ ÏóÖÎç∞Ïù¥Ìä∏ Î∞è Î™®Îã¨ Ïó¥Í∏∞
        set({ currentCut: result.data, modalOpen: true })
        console.log('timelineStore cut details loaded and modal opened:', result.data)
        return { success: true, data: result.data }
      } else {
        set({ error: result.error })
        console.error('timelineStore loadCutDetails failed:', result.error)
        return { success: false, error: result.error }
      }
    } catch (error) {
      const errorMessage = 'Ïª∑ ÏÉÅÏÑ∏ Ï†ïÎ≥¥Î•º Î∂àÎü¨Ïò§ÎäîÎç∞ Ïã§Ìå®ÌñàÏäµÎãàÎã§.'
      set({ error: errorMessage })
      console.error('timelineStore loadCutDetails error:', error)
      return { success: false, error: errorMessage }
    }
  },

  /**
   * Ïî¨ ÏÉÅÏÑ∏ Ï†ïÎ≥¥ Î°úÎìú
   */
  loadSceneDetails: async (sceneId) => {
    const { currentProjectId } = get()
    if (!currentProjectId) {
      return { success: false, error: 'ÌîÑÎ°úÏ†ùÌä∏Í∞Ä ÏÑ†ÌÉùÎêòÏßÄ ÏïäÏïòÏäµÎãàÎã§.' }
    }

    try {
      console.log('timelineStore loadSceneDetails started for sceneId:', sceneId)
      const result = await timelineService.getSceneDetails(currentProjectId, sceneId)
      
      if (result.success) {
        // ÌòÑÏû¨ Ïî¨ ÏóÖÎç∞Ïù¥Ìä∏ Î∞è Î™®Îã¨ Ïó¥Í∏∞
        set({ currentScene: result.data, modalOpen: true })
        console.log('timelineStore scene details loaded and modal opened:', result.data)
        return { success: true, data: result.data }
      } else {
        set({ error: result.error })
        console.error('timelineStore loadSceneDetails failed:', result.error)
        return { success: false, error: result.error }
      }
    } catch (error) {
      const errorMessage = 'Ïî¨ ÏÉÅÏÑ∏ Ï†ïÎ≥¥Î•º Î∂àÎü¨Ïò§ÎäîÎç∞ Ïã§Ìå®ÌñàÏäµÎãàÎã§.'
      set({ error: errorMessage })
      console.error('timelineStore loadSceneDetails error:', error)
      return { success: false, error: errorMessage }
    }
  },

  /**
   * Ïª∑ ÏóÖÎç∞Ïù¥Ìä∏ (API Ïó∞Îèô)
   */
  updateCutWithAPI: async (cutId, updates) => {
    const { currentProjectId } = get()
    if (!currentProjectId) {
      return { success: false, error: 'ÌîÑÎ°úÏ†ùÌä∏Í∞Ä ÏÑ†ÌÉùÎêòÏßÄ ÏïäÏïòÏäµÎãàÎã§.' }
    }

    try {
      const result = await timelineService.updateCut(currentProjectId, cutId, updates)
      
      if (result.success) {
        // Î°úÏª¨ ÏÉÅÌÉú ÏóÖÎç∞Ïù¥Ìä∏
        set((state) => ({
          cuts: state.cuts.map(cut =>
            cut.id === cutId ? { ...cut, ...updates } : cut
          )
        }))
        
        // Ï∫êÏãú ÏóÖÎç∞Ïù¥Ìä∏
        timelineService.clearCache(`project_${currentProjectId}`)
        
        return { success: true, data: result.data }
      } else {
        set({ error: result.error })
        return { success: false, error: result.error }
      }
    } catch (error) {
      const errorMessage = 'Ïª∑ ÏóÖÎç∞Ïù¥Ìä∏Ïóê Ïã§Ìå®ÌñàÏäµÎãàÎã§.'
      set({ error: errorMessage })
      return { success: false, error: errorMessage }
    }
  },

  /**
   * Ïª∑ ÏÇ≠Ï†ú (API Ïó∞Îèô)
   */
  deleteCutWithAPI: async (cutId) => {
    const { currentProjectId } = get()
    if (!currentProjectId) {
      return { success: false, error: 'ÌîÑÎ°úÏ†ùÌä∏Í∞Ä ÏÑ†ÌÉùÎêòÏßÄ ÏïäÏïòÏäµÎãàÎã§.' }
    }

    try {
      const result = await timelineService.deleteCut(currentProjectId, cutId)
      
      if (result.success) {
        // Î°úÏª¨ ÏÉÅÌÉú ÏóÖÎç∞Ïù¥Ìä∏
        set((state) => ({
          cuts: state.cuts.filter(cut => cut.id !== cutId),
          selectedCutId: state.selectedCutId === cutId ? null : state.selectedCutId
        }))
        
        // Ï∫êÏãú ÏóÖÎç∞Ïù¥Ìä∏
        timelineService.clearCache(`project_${currentProjectId}`)
        
        return { success: true }
      } else {
        set({ error: result.error })
        return { success: false, error: result.error }
      }
    } catch (error) {
      const errorMessage = 'Ïª∑ ÏÇ≠Ï†úÏóê Ïã§Ìå®ÌñàÏäµÎãàÎã§.'
      set({ error: errorMessage })
      return { success: false, error: errorMessage }
    }
  },

  /**
   * Ïã§ÏãúÍ∞Ñ ÏóÖÎç∞Ïù¥Ìä∏ Ïó∞Í≤∞
   */
  connectRealtimeUpdates: (projectId) => {
    try {
      const ws = timelineService.connectRealtimeUpdates(projectId, (data) => {
        console.log('üì® timelineStore Ïã§ÏãúÍ∞Ñ ÏóÖÎç∞Ïù¥Ìä∏ ÏàòÏã†:', data)
        
        // ÏóÖÎç∞Ïù¥Ìä∏ ÌÉÄÏûÖÏóê Îî∞Îùº Ï≤òÎ¶¨
        if (data.type === 'cut_updated') {
          get().updateCut(data.cutId, data.updates)
        } else if (data.type === 'cut_deleted') {
          get().deleteCut(data.cutId)
        } else if (data.type === 'cut_created') {
          get().addCut(data.cut)
        } else if (data.type === 'scene_updated') {
          get().updateScene(data.sceneId, data.updates)
        } else if (data.type === 'scene_deleted') {
          get().deleteScene(data.sceneId)
        } else if (data.type === 'scene_created') {
          get().addScene(data.scene)
        }
      })
      
      set({ websocketConnection: ws })
      console.log('‚úÖ timelineStore WebSocket Ïó∞Í≤∞ ÏÑ§Ï†ï ÏôÑÎ£å')
    } catch (error) {
      console.error('‚ùå timelineStore WebSocket Ïó∞Í≤∞ Ïã§Ìå®:', error)
    }
  },

  /**
   * Ïã§ÏãúÍ∞Ñ ÏóÖÎç∞Ïù¥Ìä∏ Ïó∞Í≤∞ Ìï¥Ï†ú
   */
  disconnectRealtimeUpdates: () => {
    const { websocketConnection } = get()
    if (websocketConnection) {
      websocketConnection.close()
      set({ websocketConnection: null })
      console.log('üîå timelineStore WebSocket Ïó∞Í≤∞ Ìï¥Ï†ú ÏôÑÎ£å')
    }
  },

  /**
   * ÌïÑÌÑ∞ ÏÑ§Ï†ï
   */
  setFilter: (filterKey, value) => {
    set((state) => ({
      filters: {
        ...state.filters,
        [filterKey]: value
      }
    }))
  },

  /**
   * Î™®Îì† ÌïÑÌÑ∞ Ï¥àÍ∏∞Ìôî
   */
  clearFilters: () => {
    set({
      filters: {
        type: null,
        dateRange: null,
        location: null,
        character: null,
        equipment: null,
      }
    })
  },

  /**
   * Ï†ïÎ†¨ Í∏∞Ï§Ä ÏÑ§Ï†ï
   */
  setSortBy: (sortBy) => {
    set({ sortBy })
  },

  /**
   * Î™®Îã¨ Ïó¥Í∏∞
   */
  openModal: (cut) => {
    set({ modalOpen: true, currentCut: cut })
  },

  /**
   * Î™®Îã¨ Îã´Í∏∞
   */
  closeModal: () => {
    set({ modalOpen: false, currentCut: null })
  },

  /**
   * ÌïÑÌÑ∞ÎßÅÎêú Ïª∑Îì§ Í∞ÄÏ†∏Ïò§Í∏∞
   */
  getFilteredCuts: () => {
    const { cuts, filters, sortBy } = get()
    
    let filteredCuts = [...cuts]

    // ÌÉÄÏûÖÎ≥Ñ ÌïÑÌÑ∞ÎßÅ
    if (filters.type) {
      filteredCuts = filteredCuts.filter(cut => cut.type === filters.type)
    }

    // ÎÇ†Ïßú Î≤îÏúÑ ÌïÑÌÑ∞ÎßÅ
    if (filters.dateRange) {
      filteredCuts = filteredCuts.filter(cut => {
        const cutDate = new Date(cut.createdAt)
        return cutDate >= filters.dateRange.start && cutDate <= filters.dateRange.end
      })
    }

    // Ïû•ÏÜåÎ≥Ñ ÌïÑÌÑ∞ÎßÅ
    if (filters.location) {
      filteredCuts = filteredCuts.filter(cut => {
        return cut.nodes?.some(node => 
          node.type === 'location' && 
          node.value.toLowerCase().includes(filters.location.toLowerCase())
        )
      })
    }

    // Îì±Ïû•Ïù∏Î¨ºÎ≥Ñ ÌïÑÌÑ∞ÎßÅ
    if (filters.character) {
      filteredCuts = filteredCuts.filter(cut => {
        return cut.nodes?.some(node => 
          node.type === 'character' && 
          node.value.toLowerCase().includes(filters.character.toLowerCase())
        )
      })
    }

    // Ïû•ÎπÑÎ≥Ñ ÌïÑÌÑ∞ÎßÅ
    if (filters.equipment) {
      filteredCuts = filteredCuts.filter(cut => {
        return cut.nodes?.some(node => 
          node.type === 'equipment' && 
          node.value.toLowerCase().includes(filters.equipment.toLowerCase())
        )
      })
    }

    // Ï†ïÎ†¨
    switch (sortBy) {
      case 'cut_number':
        filteredCuts.sort((a, b) => 
          (a.shotNumber || 0) - (b.shotNumber || 0)
        )
        break
      case 'duration':
        filteredCuts.sort((a, b) => (a.duration || 0) - (b.duration || 0))
        break
      case 'created_at':
        filteredCuts.sort((a, b) => new Date(b.createdAt) - new Date(a.createdAt))
        break
      case 'type':
        filteredCuts.sort((a, b) => a.type.localeCompare(b.type))
        break
      default:
        break
    }

    return filteredCuts
  },

  /**
   * ÌÉÄÏûÖÎ≥Ñ Ïî¨ Í∞úÏàò Í∞ÄÏ†∏Ïò§Í∏∞
   */
  getSceneCounts: () => {
    const { cuts } = get()
    return {
      total: cuts.length,
      generatedVideo: cuts.filter(cut => cut.type === SceneType.GENERATED_VIDEO).length,
      liveAction: cuts.filter(cut => cut.type === SceneType.LIVE_ACTION).length,
    }
  },

  /**
   * Ï¥ù ÏßÄÏÜç ÏãúÍ∞Ñ Í≥ÑÏÇ∞
   */
  getTotalDuration: () => {
    const { cuts } = get()
    return cuts.reduce((total, cut) => total + (cut.duration || 0), 0)
  },

  /**
   * ÎÖ∏ÎìúÎ≥Ñ ÌÜµÍ≥Ñ Í∞ÄÏ†∏Ïò§Í∏∞
   */
  getNodeStats: () => {
    const { cuts } = get()
    const stats = {}

    cuts.forEach(cut => {
      cut.nodes?.forEach(node => {
        if (!stats[node.type]) {
          stats[node.type] = new Set()
        }
        stats[node.type].add(node.value)
      })
    })

    return Object.fromEntries(
      Object.entries(stats).map(([type, values]) => [type, Array.from(values)])
    )
  },

  /**
   * Ïî¨ ÏàúÏÑú Î≥ÄÍ≤Ω
   */
  updateScenesOrder: (newScenes) => {
    // Ïù¥ Ìï®ÏàòÎäî Ïª∑ Ï§ëÏã¨ÏúºÎ°ú Î≥ÄÍ≤ΩÎêòÏóàÏúºÎØÄÎ°ú ÏÇ¨Ïö©ÎêòÏßÄ ÏïäÏùå
    console.log('updateScenesOrder Ìò∏Ï∂úÎê® (Ïª∑ Ï§ëÏã¨ Ïä§ÌÜ†Ïñ¥ÏóêÏÑúÎäî ÏÇ¨Ïö©ÎêòÏßÄ ÏïäÏùå)')
  },

  /**
   * Ïª∑ ÏàúÏÑú Î≥ÄÍ≤Ω
   */
  updateCutsOrder: (newCuts) => {
    // Î™®Îì† Ïª∑ÏùÑ ÌèâÎ©¥ÌôîÌïòÏó¨ ÏàúÏÑú Î≥ÄÍ≤Ω
    const allCuts = []
    const cuts = get().cuts
    
    cuts.forEach(cut => {
      allCuts.push({
        ...cut,
        sceneId: cut.sceneId // Ïª∑Ïùò sceneIdÎ•º Ìè¨Ìï®
      })
    })
    
    // ÏÉàÎ°úÏö¥ ÏàúÏÑúÎ°ú Ïª∑Îì§ÏùÑ Îã§Ïãú Ïî¨Ïóê Î∞∞Ïπò
    const updatedCuts = newCuts.map(cut => {
      const sceneCuts = allCuts.filter(c => c.sceneId === cut.sceneId)
      return {
        ...cut,
        cuts: sceneCuts
      }
    })
    
    set({ cuts: updatedCuts })
  },

  /**
   * Ïä§ÏºÄÏ§ÑÎßÅ ÏµúÏ†ÅÌôî (Ìñ•ÌõÑ Íµ¨ÌòÑ)
   */
  optimizeSchedule: () => {
    // TODO: Í∑∏ÎûòÌîÑ ÏïåÍ≥†Î¶¨Ï¶òÏùÑ ÏÇ¨Ïö©Ìïú Ïä§ÏºÄÏ§ÑÎßÅ ÏµúÏ†ÅÌôî
    console.log('Ïä§ÏºÄÏ§ÑÎßÅ ÏµúÏ†ÅÌôî Í∏∞Îä•ÏùÄ Ìñ•ÌõÑ Íµ¨ÌòÑ ÏòàÏ†ïÏûÖÎãàÎã§.')
  }
}))

export default useTimelineStore 