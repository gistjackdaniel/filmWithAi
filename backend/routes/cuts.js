const express = require('express');
const jwt = require('jsonwebtoken');
const Project = require('../models/Project');
const Conte = require('../models/Conte');
const Cut = require('../models/Cut');

const router = express.Router();

/**
 * ÏÇ¨Ïö©Ïûê Ïù∏Ï¶ù ÎØ∏Îì§Ïõ®Ïñ¥
 * JWT ÌÜ†ÌÅ∞ÏùÑ Í≤ÄÏ¶ùÌïòÏó¨ ÏÇ¨Ïö©Ïûê Ï†ïÎ≥¥Î•º req.userÏóê ÏÑ§Ï†ï
 */
const authenticateToken = async (req, res, next) => {
  try {
    const authHeader = req.headers['authorization'];
    const token = authHeader && authHeader.split(' ')[1]; // Bearer TOKEN

    if (!token) {
      return res.status(401).json({ 
        success: false, 
        message: 'Ïï°ÏÑ∏Ïä§ ÌÜ†ÌÅ∞Ïù¥ ÌïÑÏöîÌï©ÎãàÎã§.' 
      });
    }

    // JWT ÌÜ†ÌÅ∞ Í≤ÄÏ¶ù
    const decoded = jwt.verify(token, process.env.JWT_SECRET || 'your-secret-key');
    const User = require('../models/User');
    const user = await User.findById(decoded.userId);
    
    if (!user) {
      return res.status(401).json({ 
        success: false, 
        message: 'Ïú†Ìö®ÌïòÏßÄ ÏïäÏùÄ ÌÜ†ÌÅ∞ÏûÖÎãàÎã§.' 
      });
    }

    req.user = user;
    next();
  } catch (error) {
    console.error('ÌÜ†ÌÅ∞ Í≤ÄÏ¶ù Ïò§Î•ò:', error);
    return res.status(403).json({ 
      success: false, 
      message: 'ÌÜ†ÌÅ∞Ïù¥ Ïú†Ìö®ÌïòÏßÄ ÏïäÏäµÎãàÎã§.' 
    });
  }
};

/**
 * ÌîÑÎ°úÏ†ùÌä∏ Í∂åÌïú ÌôïÏù∏ ÎØ∏Îì§Ïõ®Ïñ¥
 * ÏÇ¨Ïö©ÏûêÍ∞Ä Ìï¥Îãπ ÌîÑÎ°úÏ†ùÌä∏Ïóê Ï†ëÍ∑º Í∂åÌïúÏù¥ ÏûàÎäîÏßÄ ÌôïÏù∏
 */
const checkProjectAccess = async (req, res, next) => {
  try {
    const { projectId } = req.params;

    const ProjectModel = require('../models/Project');
    const project = await ProjectModel.findOne({
      _id: projectId,
      userId: req.user._id,
      isDeleted: false
    });

    if (!project) {
      return res.status(404).json({
        success: false,
        message: 'ÌîÑÎ°úÏ†ùÌä∏Î•º Ï∞æÏùÑ Ïàò ÏóÜÏäµÎãàÎã§.'
      });
    }

    req.project = project;
    next();
  } catch (error) {
    console.error('ÌîÑÎ°úÏ†ùÌä∏ Í∂åÌïú ÌôïÏù∏ Ïò§Î•ò:', error);
    res.status(500).json({
      success: false,
      message: 'ÌîÑÎ°úÏ†ùÌä∏ Í∂åÌïú ÌôïÏù∏ Ï§ë Ïò§Î•òÍ∞Ä Î∞úÏÉùÌñàÏäµÎãàÎã§.'
    });
  }
};

/**
 * Ïî¨(Conte) Í∂åÌïú ÌôïÏù∏ ÎØ∏Îì§Ïõ®Ïñ¥
 * Ìï¥Îãπ Ïî¨Ïù¥ ÌîÑÎ°úÏ†ùÌä∏Ïóê ÏÜçÌïòÎäîÏßÄ ÌôïÏù∏
 */
const checkConteAccess = async (req, res, next) => {
  try {
    const { projectId, conteId } = req.params;

    const conte = await Conte.findOne({
      _id: conteId,
      projectId: projectId
    });

    if (!conte) {
      return res.status(404).json({
        success: false,
        message: 'Ïî¨ÏùÑ Ï∞æÏùÑ Ïàò ÏóÜÏäµÎãàÎã§.'
      });
    }

    req.conte = conte;
    next();
  } catch (error) {
    console.error('Ïî¨ Í∂åÌïú ÌôïÏù∏ Ïò§Î•ò:', error);
    res.status(500).json({
      success: false,
      message: 'Ïî¨ Í∂åÌïú ÌôïÏù∏ Ï§ë Ïò§Î•òÍ∞Ä Î∞úÏÉùÌñàÏäµÎãàÎã§.'
    });
  }
};

/**
 * Ïª∑ ÏÉùÏÑ±
 * POST /api/projects/:projectId/contes/:conteId/cuts
 */
router.post('/:projectId/contes/:conteId/cuts', authenticateToken, checkProjectAccess, checkConteAccess, async (req, res) => {
  try {
    const { projectId, conteId } = req.params;
    const {
      shotNumber,
      title,
      description,
      shootingPlan,
      cutType,
      dialogue,
      narration,
      characterMovement,
      productionMethod,
      estimatedDuration,
      shootingConditions,
      requiredPersonnel,
      requiredEquipment,
      order,
      metadata
    } = req.body;

    console.log('üíæ Ïª∑ Ï†ÄÏû• ÏöîÏ≤≠ ÏãúÏûë:', { 
      projectId, 
      conteId,
      shotNumber, 
      title: title?.substring(0, 50) + '...',
      hasDescription: !!description,
      productionMethod,
      requestBody: req.body
    });

    // ÌïÑÏàò ÌïÑÎìú Í≤ÄÏ¶ù
    if (!shotNumber || !title || !description) {
      console.error('‚ùå Ïª∑ Ï†ÄÏû• Ïã§Ìå®: ÌïÑÏàò ÌïÑÎìú ÎàÑÎùΩ', { shotNumber, title, description });
      return res.status(400).json({
        success: false,
        message: 'ÏÉ∑ Î≤àÌò∏, Ï†úÎ™©, ÏÑ§Î™ÖÏùÄ ÌïÑÏàòÏûÖÎãàÎã§.'
      });
    }

    // Ï§ëÎ≥µ Ï†ÄÏû• Î∞©ÏßÄ: Í∞ôÏùÄ Ïî¨Ïùò Í∞ôÏùÄ ÏÉ∑ Î≤àÌò∏Í∞Ä Ïù¥ÎØ∏ Ï°¥Ïû¨ÌïòÎäîÏßÄ ÌôïÏù∏
    const existingCut = await Cut.findOne({ 
      conteId: conteId, 
      shotNumber: shotNumber 
    });
    
    if (existingCut) {
      console.log('‚ö†Ô∏è Ï§ëÎ≥µ Ïª∑ Í∞êÏßÄ:', { 
        conteId, 
        shotNumber, 
        existingCutId: existingCut._id,
        existingTitle: existingCut.title 
      });
      
      return res.status(409).json({
        success: false,
        message: `ÏÉ∑ ${shotNumber}Î≤à Ïª∑Ïù¥ Ïù¥ÎØ∏ Ï°¥Ïû¨Ìï©ÎãàÎã§.`,
        data: {
          existingCut: {
            id: existingCut._id,
            shotNumber: existingCut.shotNumber,
            title: existingCut.title
          }
        }
      });
    }

    // ÏÉà Ïª∑ ÏÉùÏÑ±
    const cut = new Cut({
      conteId,
      projectId,
      shotNumber,
      title,
      description,
      shootingPlan: shootingPlan || {},
      cutType: cutType || 'medium_shot',
      dialogue: dialogue || '',
      narration: narration || '',
      characterMovement: characterMovement || {
        characters: [],
        blocking: '',
        cameraPosition: { x: 50, y: 50, z: 0 }
      },
      productionMethod: productionMethod || 'live_action',
      estimatedDuration: estimatedDuration || 5,
      shootingConditions: shootingConditions || {},
      requiredPersonnel: requiredPersonnel || {},
      requiredEquipment: requiredEquipment || {},
      order: order || shotNumber,
      metadata: metadata || {}
    });

    console.log('üíæ Ïª∑ Ï†ÄÏû• Ï§ë...', { 
      cutId: cut._id,
      conteId: cut.conteId,
      shotNumber: cut.shotNumber,
      title: cut.title 
    });
    
    await cut.save();
    console.log('‚úÖ Ïª∑ Ï†ÄÏû• ÏôÑÎ£å:', { id: cut._id, shotNumber: cut.shotNumber, title: cut.title });

    res.status(201).json({
      success: true,
      message: 'Ïª∑Ïù¥ ÏÉùÏÑ±ÎêòÏóàÏäµÎãàÎã§.',
      data: {
        cut: {
          id: cut._id,
          shotNumber: cut.shotNumber,
          title: cut.title,
          description: cut.description,
          productionMethod: cut.productionMethod,
          estimatedDuration: cut.estimatedDuration,
          order: cut.order,
          status: cut.status,
          createdAt: cut.createdAt
        }
      }
    });

  } catch (error) {
    console.error('‚ùå Ïª∑ ÏÉùÏÑ± Ïò§Î•ò:', error);
    res.status(500).json({
      success: false,
      message: 'Ïª∑ ÏÉùÏÑ± Ï§ë Ïò§Î•òÍ∞Ä Î∞úÏÉùÌñàÏäµÎãàÎã§.'
    });
  }
});

/**
 * Ïî¨Ïùò Ïª∑ Î™©Î°ù Ï°∞Ìöå
 * GET /api/projects/:projectId/contes/:conteId/cuts
 */
router.get('/:projectId/contes/:conteId/cuts', authenticateToken, checkProjectAccess, checkConteAccess, async (req, res) => {
  try {
    const { conteId } = req.params;
    const { status, productionMethod } = req.query;
    const options = { status, productionMethod };

    const cuts = await Cut.findByConteId(conteId, options);

    res.status(200).json({
      success: true,
      data: {
        cuts: cuts.map(cut => ({
          id: cut._id,
          shotNumber: cut.shotNumber,
          title: cut.title,
          description: cut.description,
          shootingPlan: cut.shootingPlan,
          cutType: cut.cutType,
          dialogue: cut.dialogue,
          narration: cut.narration,
          characterMovement: cut.characterMovement,
          productionMethod: cut.productionMethod,
          estimatedDuration: cut.estimatedDuration,
          durationFormatted: cut.durationFormatted,
          shootingConditions: cut.shootingConditions,
          requiredPersonnel: cut.requiredPersonnel,
          requiredEquipment: cut.requiredEquipment,
          output: cut.output,
          order: cut.order,
          status: cut.status,
          canEdit: cut.canEdit,
          metadata: cut.metadata,
          lastModified: cut.lastModified,
          modifiedBy: cut.modifiedBy,
          createdAt: cut.createdAt,
          updatedAt: cut.updatedAt
        }))
      }
    });

  } catch (error) {
    console.error('Ïª∑ Î™©Î°ù Ï°∞Ìöå Ïò§Î•ò:', error);
    res.status(500).json({
      success: false,
      message: 'Ïª∑ Î™©Î°ù Ï°∞Ìöå Ï§ë Ïò§Î•òÍ∞Ä Î∞úÏÉùÌñàÏäµÎãàÎã§.'
    });
  }
});

/**
 * ÌäπÏ†ï Ïª∑ Ï°∞Ìöå
 * GET /api/projects/:projectId/contes/:conteId/cuts/:cutId
 */
router.get('/:projectId/contes/:conteId/cuts/:cutId', authenticateToken, checkProjectAccess, checkConteAccess, async (req, res) => {
  try {
    const { cutId } = req.params;

    const cut = await Cut.findOne({
      _id: cutId,
      conteId: req.params.conteId
    }).populate('conteId', 'scene title').populate('projectId', 'projectTitle');

    if (!cut) {
      return res.status(404).json({
        success: false,
        message: 'Ïª∑ÏùÑ Ï∞æÏùÑ Ïàò ÏóÜÏäµÎãàÎã§.'
      });
    }

    res.status(200).json({
      success: true,
      data: {
        cut: {
          id: cut._id,
          shotNumber: cut.shotNumber,
          title: cut.title,
          description: cut.description,
          shootingPlan: cut.shootingPlan,
          productionMethod: cut.productionMethod,
          estimatedDuration: cut.estimatedDuration,
          durationFormatted: cut.durationFormatted,
          shootingConditions: cut.shootingConditions,
          requiredPersonnel: cut.requiredPersonnel,
          requiredEquipment: cut.requiredEquipment,
          output: cut.output,
          order: cut.order,
          status: cut.status,
          canEdit: cut.canEdit,
          metadata: cut.metadata,
          lastModified: cut.lastModified,
          modifiedBy: cut.modifiedBy,
          createdAt: cut.createdAt,
          updatedAt: cut.updatedAt,
          conte: {
            id: cut.conteId._id,
            scene: cut.conteId.scene,
            title: cut.conteId.title
          },
          project: {
            id: cut.projectId._id,
            projectTitle: cut.projectId.projectTitle
          }
        }
      }
    });

  } catch (error) {
    console.error('Ïª∑ Ï°∞Ìöå Ïò§Î•ò:', error);
    res.status(500).json({
      success: false,
      message: 'Ïª∑ Ï°∞Ìöå Ï§ë Ïò§Î•òÍ∞Ä Î∞úÏÉùÌñàÏäµÎãàÎã§.'
    });
  }
});

/**
 * Ïª∑ ÏóÖÎç∞Ïù¥Ìä∏
 * PUT /api/projects/:projectId/contes/:conteId/cuts/:cutId
 */
router.put('/:projectId/contes/:conteId/cuts/:cutId', authenticateToken, checkProjectAccess, checkConteAccess, async (req, res) => {
  try {
    const { cutId } = req.params;
    const updateData = req.body;

    const cut = await Cut.findOne({
      _id: cutId,
      conteId: req.params.conteId
    });

    if (!cut) {
      return res.status(404).json({
        success: false,
        message: 'Ïª∑ÏùÑ Ï∞æÏùÑ Ïàò ÏóÜÏäµÎãàÎã§.'
      });
    }

    // Ìé∏Ïßë Í∂åÌïú ÌôïÏù∏
    if (!cut.canEdit) {
      return res.status(403).json({
        success: false,
        message: 'Ïù¥ Ïª∑ÏùÄ Ìé∏ÏßëÌï† Ïàò ÏóÜÏäµÎãàÎã§.'
      });
    }

    // ÏóÖÎç∞Ïù¥Ìä∏Ìï† ÌïÑÎìú ÏÑ§Ï†ï
    Object.keys(updateData).forEach(key => {
      if (cut.schema.paths[key]) {
        cut[key] = updateData[key];
      }
    });

    // ÏàòÏ†ï Ï†ïÎ≥¥ ÏóÖÎç∞Ïù¥Ìä∏
    cut.lastModified = new Date();
    cut.modifiedBy = req.user.name;

    await cut.save();

    res.status(200).json({
      success: true,
      message: 'Ïª∑Ïù¥ ÏóÖÎç∞Ïù¥Ìä∏ÎêòÏóàÏäµÎãàÎã§.',
      data: {
        cut: {
          id: cut._id,
          shotNumber: cut.shotNumber,
          title: cut.title,
          description: cut.description,
          productionMethod: cut.productionMethod,
          estimatedDuration: cut.estimatedDuration,
          order: cut.order,
          status: cut.status,
          lastModified: cut.lastModified,
          modifiedBy: cut.modifiedBy,
          updatedAt: cut.updatedAt
        }
      }
    });

  } catch (error) {
    console.error('Ïª∑ ÏóÖÎç∞Ïù¥Ìä∏ Ïò§Î•ò:', error);
    res.status(500).json({
      success: false,
      message: 'Ïª∑ ÏóÖÎç∞Ïù¥Ìä∏ Ï§ë Ïò§Î•òÍ∞Ä Î∞úÏÉùÌñàÏäµÎãàÎã§.'
    });
  }
});

/**
 * Ïª∑ ÏàúÏÑú Î≥ÄÍ≤Ω
 * PUT /api/projects/:projectId/contes/:conteId/cuts/reorder
 */
router.put('/:projectId/contes/:conteId/cuts/reorder', authenticateToken, checkProjectAccess, checkConteAccess, async (req, res) => {
  try {
    const { conteId } = req.params;
    const { cutOrders } = req.body; // [{ cutId, newOrder }]

    if (!Array.isArray(cutOrders)) {
      return res.status(400).json({
        success: false,
        message: 'Ïª∑ ÏàúÏÑú Ï†ïÎ≥¥Í∞Ä Ïò¨Î∞îÎ•¥ÏßÄ ÏïäÏäµÎãàÎã§.'
      });
    }

    // ÏàúÏÑú ÏóÖÎç∞Ïù¥Ìä∏
    const updatePromises = cutOrders.map(({ cutId, newOrder }) => {
      return Cut.findOneAndUpdate(
        { _id: cutId, conteId },
        { order: newOrder },
        { new: true }
      );
    });

    await Promise.all(updatePromises);

    res.status(200).json({
      success: true,
      message: 'Ïª∑ ÏàúÏÑúÍ∞Ä Î≥ÄÍ≤ΩÎêòÏóàÏäµÎãàÎã§.'
    });

  } catch (error) {
    console.error('Ïª∑ ÏàúÏÑú Î≥ÄÍ≤Ω Ïò§Î•ò:', error);
    res.status(500).json({
      success: false,
      message: 'Ïª∑ ÏàúÏÑú Î≥ÄÍ≤Ω Ï§ë Ïò§Î•òÍ∞Ä Î∞úÏÉùÌñàÏäµÎãàÎã§.'
    });
  }
});

/**
 * Ïª∑ ÏÇ≠Ï†ú
 * DELETE /api/projects/:projectId/contes/:conteId/cuts/:cutId
 */
router.delete('/:projectId/contes/:conteId/cuts/:cutId', authenticateToken, checkProjectAccess, checkConteAccess, async (req, res) => {
  try {
    const { cutId } = req.params;

    const cut = await Cut.findOne({
      _id: cutId,
      conteId: req.params.conteId
    });

    if (!cut) {
      return res.status(404).json({
        success: false,
        message: 'Ïª∑ÏùÑ Ï∞æÏùÑ Ïàò ÏóÜÏäµÎãàÎã§.'
      });
    }

    await Cut.findByIdAndDelete(cutId);

    res.status(200).json({
      success: true,
      message: 'Ïª∑Ïù¥ ÏÇ≠Ï†úÎêòÏóàÏäµÎãàÎã§.'
    });

  } catch (error) {
    console.error('Ïª∑ ÏÇ≠Ï†ú Ïò§Î•ò:', error);
    res.status(500).json({
      success: false,
      message: 'Ïª∑ ÏÇ≠Ï†ú Ï§ë Ïò§Î•òÍ∞Ä Î∞úÏÉùÌñàÏäµÎãàÎã§.'
    });
  }
});

/**
 * Í∞ôÏùÄ Ïû•ÏÜåÏùò Ïª∑Îì§ Ï°∞Ìöå
 * GET /api/projects/:projectId/cuts/location/:location
 */
router.get('/:projectId/cuts/location/:location', authenticateToken, checkProjectAccess, async (req, res) => {
  try {
    const { projectId, location } = req.params;

    const cuts = await Cut.findByLocation(projectId, location);

    res.status(200).json({
      success: true,
      data: {
        location,
        cuts: cuts.map(cut => ({
          id: cut._id,
          shotNumber: cut.shotNumber,
          title: cut.title,
          productionMethod: cut.productionMethod,
          order: cut.order,
          status: cut.status
        }))
      }
    });

  } catch (error) {
    console.error('Ïû•ÏÜåÎ≥Ñ Ïª∑ Ï°∞Ìöå Ïò§Î•ò:', error);
    res.status(500).json({
      success: false,
      message: 'Ïû•ÏÜåÎ≥Ñ Ïª∑ Ï°∞Ìöå Ï§ë Ïò§Î•òÍ∞Ä Î∞úÏÉùÌñàÏäµÎãàÎã§.'
    });
  }
});

/**
 * Í∞ôÏùÄ ÏãúÍ∞ÑÎåÄÏùò Ïª∑Îì§ Ï°∞Ìöå
 * GET /api/projects/:projectId/cuts/time/:timeOfDay
 */
router.get('/:projectId/cuts/time/:timeOfDay', authenticateToken, checkProjectAccess, async (req, res) => {
  try {
    const { projectId, timeOfDay } = req.params;

    const cuts = await Cut.findByTimeOfDay(projectId, timeOfDay);

    res.status(200).json({
      success: true,
      data: {
        timeOfDay,
        cuts: cuts.map(cut => ({
          id: cut._id,
          shotNumber: cut.shotNumber,
          title: cut.title,
          productionMethod: cut.productionMethod,
          order: cut.order,
          status: cut.status
        }))
      }
    });

  } catch (error) {
    console.error('ÏãúÍ∞ÑÎåÄÎ≥Ñ Ïª∑ Ï°∞Ìöå Ïò§Î•ò:', error);
    res.status(500).json({
      success: false,
      message: 'ÏãúÍ∞ÑÎåÄÎ≥Ñ Ïª∑ Ï°∞Ìöå Ï§ë Ïò§Î•òÍ∞Ä Î∞úÏÉùÌñàÏäµÎãàÎã§.'
    });
  }
});

/**
 * Ï†úÏûë Î∞©Î≤ïÎ≥Ñ Ïª∑Îì§ Ï°∞Ìöå
 * GET /api/projects/:projectId/cuts/method/:method
 */
router.get('/:projectId/cuts/method/:method', authenticateToken, checkProjectAccess, async (req, res) => {
  try {
    const { projectId, method } = req.params;

    const cuts = await Cut.findByProductionMethod(projectId, method);

    res.status(200).json({
      success: true,
      data: {
        productionMethod: method,
        cuts: cuts.map(cut => ({
          id: cut._id,
          shotNumber: cut.shotNumber,
          title: cut.title,
          productionMethod: cut.productionMethod,
          order: cut.order,
          status: cut.status
        }))
      }
    });

  } catch (error) {
    console.error('Ï†úÏûë Î∞©Î≤ïÎ≥Ñ Ïª∑ Ï°∞Ìöå Ïò§Î•ò:', error);
    res.status(500).json({
      success: false,
      message: 'Ï†úÏûë Î∞©Î≤ïÎ≥Ñ Ïª∑ Ï°∞Ìöå Ï§ë Ïò§Î•òÍ∞Ä Î∞úÏÉùÌñàÏäµÎãàÎã§.'
    });
  }
});

/**
 * Ïª∑ ÌÉÄÏûÖÎ≥Ñ Ïª∑Îì§ Ï°∞Ìöå
 * GET /api/projects/:projectId/cuts/type/:cutType
 */
router.get('/:projectId/cuts/type/:cutType', authenticateToken, checkProjectAccess, async (req, res) => {
  try {
    const { projectId, cutType } = req.params;

    const cuts = await Cut.find({
      projectId,
      cutType: cutType
    }).sort({ order: 1 });

    res.status(200).json({
      success: true,
      data: {
        cutType: cutType,
        cuts: cuts.map(cut => ({
          id: cut._id,
          shotNumber: cut.shotNumber,
          title: cut.title,
          cutType: cut.cutType,
          order: cut.order,
          status: cut.status
        }))
      }
    });

  } catch (error) {
    console.error('Ïª∑ ÌÉÄÏûÖÎ≥Ñ Ïª∑ Ï°∞Ìöå Ïò§Î•ò:', error);
    res.status(500).json({
      success: false,
      message: 'Ïª∑ ÌÉÄÏûÖÎ≥Ñ Ïª∑ Ï°∞Ìöå Ï§ë Ïò§Î•òÍ∞Ä Î∞úÏÉùÌñàÏäµÎãàÎã§.'
    });
  }
});

/**
 * AI Ïª∑ ÏÑ∏Î∂ÑÌôî ÏÉùÏÑ±
 * POST /api/projects/:projectId/contes/:conteId/cuts/segment
 */
router.post('/:projectId/contes/:conteId/cuts/segment', authenticateToken, checkProjectAccess, checkConteAccess, async (req, res) => {
  try {
    const { conteId } = req.params;
    const { 
      segmentationMethod = 'auto',
      maxCuts = 5,
      focusAreas = []
    } = req.body;

    console.log('ü§ñ AI Ïª∑ ÏÑ∏Î∂ÑÌôî ÏöîÏ≤≠:', { 
      conteId, 
      segmentationMethod,
      maxCuts,
      focusAreas 
    });

    // Ïî¨ Ï†ïÎ≥¥ Í∞ÄÏ†∏Ïò§Í∏∞
    const conte = await Conte.findById(conteId);
    if (!conte) {
      return res.status(404).json({
        success: false,
        message: 'Ïî¨ÏùÑ Ï∞æÏùÑ Ïàò ÏóÜÏäµÎãàÎã§.'
      });
    }

    // AI Ïª∑ ÏÑ∏Î∂ÑÌôî Î°úÏßÅ (Ïã§Ï†ú Íµ¨ÌòÑÏùÄ OpenAI API ÏÇ¨Ïö©)
    const generatedCuts = [];
    
    // ÏûÑÏãúÎ°ú Í∞ÑÎã®Ìïú Ïª∑ ÏÉùÏÑ± (Ïã§Ï†úÎ°úÎäî OpenAI API Ìò∏Ï∂ú)
    for (let i = 1; i <= maxCuts; i++) {
      const cut = {
        conteId,
        projectId: req.params.projectId,
        shotNumber: i,
        title: `ÏÉ∑ ${i}: ${conte.title.substring(0, 20)}...`,
        description: `AIÍ∞Ä ÏÉùÏÑ±Ìïú ÏÉ∑ ${i}Ïùò ÏÑ§Î™ÖÏûÖÎãàÎã§. ${conte.description.substring(0, 100)}...`,
        shootingPlan: {
          cameraAngle: i % 2 === 0 ? 'ÌÅ¥Î°úÏ¶àÏóÖ' : 'ÏôÄÏù¥ÎìúÏÉ∑',
          cameraMovement: i % 3 === 0 ? 'Ìå¨' : 'Í≥†Ï†ï',
          lensSpecs: '50mm',
          cameraSettings: {
            aperture: 'f/2.8',
            shutterSpeed: '1/60',
            iso: '800'
          },
          composition: `ÏÉ∑ ${i}Ïùò Íµ¨ÎèÑ ÏÑ§Î™ÖÏûÖÎãàÎã§.`
        },
        cutType: i % 3 === 0 ? 'close_up' : i % 3 === 1 ? 'medium_shot' : 'wide_shot',
        dialogue: i % 2 === 0 ? `ÏÉ∑ ${i}Ïùò ÎåÄÏÇ¨ÏûÖÎãàÎã§.` : '',
        narration: i % 4 === 0 ? `ÏÉ∑ ${i}Ïùò ÎÇ¥Î†àÏù¥ÏÖòÏûÖÎãàÎã§.` : '',
        characterMovement: {
          characters: [
            {
              name: 'Ï£ºÏù∏Í≥µ',
              position: { x: 30 + (i * 10), y: 50 },
              action: 'ÎåÄÌôî Ï§ë',
              emotion: 'ÏßëÏ§ë'
            }
          ],
          blocking: `ÏÉ∑ ${i}Ïùò Î∏îÎ°úÌÇπ ÏÑ§Î™ÖÏûÖÎãàÎã§.`,
          cameraPosition: { x: 50, y: 50, z: 0 }
        },
        productionMethod: i % 2 === 0 ? 'live_action' : 'ai_generated',
        estimatedDuration: 5 + (i * 2), // 5Ï¥àÎ∂ÄÌÑ∞ ÏãúÏûëÌï¥ÏÑú 2Ï¥àÏî© Ï¶ùÍ∞Ä
        shootingConditions: {
          location: conte.keywords?.location || 'Í∏∞Î≥∏ Ïû•ÏÜå',
          timeOfDay: conte.keywords?.timeOfDay || 'Ïò§ÌõÑ',
          weather: conte.weather || 'ÎßëÏùå',
          lighting: conte.lighting || 'ÏûêÏó∞Í¥ë',
          specialRequirements: []
        },
        requiredPersonnel: {
          director: 'Í∞êÎèÖ',
          cinematographer: 'Ï¥¨ÏòÅÍ∞êÎèÖ',
          cameraOperator: 'Ïπ¥Î©îÎùºÎß®',
          lightingDirector: 'Ï°∞Î™ÖÍ∞êÎèÖ',
          additionalCrew: []
        },
        requiredEquipment: {
          cameras: ['C1'],
          lenses: ['50mm'],
          lighting: ['Ï°∞Î™Ö 1ÏÑ∏Ìä∏'],
          audio: ['ÎßàÏù¥ÌÅ¨ 1Í∞ú'],
          grip: ['ÏÇºÍ∞ÅÎåÄ'],
          special: []
        },
        order: i,
        status: 'planned',
        metadata: {
          complexity: 'Î≥¥ÌÜµ',
          priority: 1,
          tags: ['AIÏÉùÏÑ±'],
          notes: ''
        }
      };

      // Ïª∑ Ï†ÄÏû•
      const newCut = new Cut(cut);
      await newCut.save();
      generatedCuts.push(newCut);
    }

    console.log('‚úÖ AI Ïª∑ ÏÑ∏Î∂ÑÌôî ÏôÑÎ£å:', { 
      conteId, 
      generatedCount: generatedCuts.length 
    });

    res.status(201).json({
      success: true,
      message: 'AI Ïª∑ ÏÑ∏Î∂ÑÌôîÍ∞Ä ÏôÑÎ£åÎêòÏóàÏäµÎãàÎã§.',
      data: {
        conteId,
        cuts: generatedCuts.map(cut => ({
          id: cut._id,
          shotNumber: cut.shotNumber,
          title: cut.title,
          description: cut.description,
          productionMethod: cut.productionMethod,
          estimatedDuration: cut.estimatedDuration,
          order: cut.order,
          status: cut.status,
          createdAt: cut.createdAt
        }))
      }
    });

  } catch (error) {
    console.error('‚ùå AI Ïª∑ ÏÑ∏Î∂ÑÌôî Ïò§Î•ò:', error);
    res.status(500).json({
      success: false,
      message: 'AI Ïª∑ ÏÑ∏Î∂ÑÌôî Ï§ë Ïò§Î•òÍ∞Ä Î∞úÏÉùÌñàÏäµÎãàÎã§.'
    });
  }
});

module.exports = router; 